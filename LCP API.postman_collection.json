{
	"info": {
		"name": "LCP API",
		"_postman_id": "d26f2d5b-c1f8-f566-14c0-ce693dc8fa38",
		"description": "",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "Accounts",
			"description": "",
			"item": [
				{
					"name": "Get account info",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));",
									"",
									"pm.environment.set('_accountId', encodeURIComponent(postman.getEnvironmentVariable('accountId').toLowerCase()));",
									""
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json",
								"disabled": true
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{url}}/accounts/{{_accountId}}",
							"host": [
								"{{url}}"
							],
							"path": [
								"accounts",
								"{{_accountId}}"
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Create Account",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json",
								"disabled": true
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"email\": \"\",\n  \"firstName\": \"\",\n  \"lastName\": \"\",\n  \"phone\": \"\",\n  \"organizationName\": \"\",\n  \"timeZone\": \"\"\n}"
						},
						"url": {
							"raw": "{{url}}/accounts/",
							"host": [
								"{{url}}"
							],
							"path": [
								"accounts",
								""
							]
						},
						"description": ""
					},
					"response": []
				}
			]
		},
		{
			"name": "Apps",
			"description": "",
			"item": [
				{
					"name": "Get app info",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"auth": {
							"type": "hawk",
							"hawk": [
								{
									"key": "authId",
									"value": "{{macKeyId}}",
									"type": "string"
								},
								{
									"key": "authKey",
									"value": "{{macKey}}",
									"type": "string"
								},
								{
									"key": "algorithm",
									"value": "sha256",
									"type": "string"
								},
								{
									"key": "user",
									"value": "",
									"type": "string"
								},
								{
									"key": "saveHelperData",
									"type": "any"
								},
								{
									"key": "nonce",
									"value": "",
									"type": "string"
								},
								{
									"key": "extraData",
									"type": "any"
								},
								{
									"key": "appId",
									"type": "any"
								},
								{
									"key": "delegation",
									"type": "any"
								},
								{
									"key": "timestamp",
									"value": "",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json",
								"disabled": true
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{url}}/apps/{{appId}}",
							"host": [
								"{{url}}"
							],
							"path": [
								"apps",
								"{{appId}}"
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Get Live Permissions for App",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"tests['Successful GET'] = responseCode.code == 200;"
								]
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{url}}/apps/{{appId}}/live-permissions/",
							"host": [
								"{{url}}"
							],
							"path": [
								"apps",
								"{{appId}}",
								"live-permissions",
								""
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Get Live Permissions for App and LP",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"tests['Successful GET'] = responseCode.code == 200;"
								]
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{url}}/apps/{{appId}}/live-permissions/{{lpId}}",
							"host": [
								"{{url}}"
							],
							"path": [
								"apps",
								"{{appId}}",
								"live-permissions",
								"{{lpId}}"
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Create Live Permissions for App on LP",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"tests['Successful POST'] = responseCode.code == 201;",
									"",
									"var responseData = JSON.parse(responseBody);",
									"postman.setEnvironmentVariable('livePermissionsId', responseData.links.self.href.match(/(?!.*\\/).*/)[0]);",
									"",
									"tests['Operations set length'] = responseData.operations.length == 4;",
									"tests['Operations set'] = responseData.operations.intersect(",
									"    [",
									"    \"member-details\",",
									"    \"mvs\",",
									"    \"debits\",",
									"    \"credits\"",
									"    ]).length == 4;"
								]
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"loyaltyProgram\": \"https://staging.lcp.points.com/v1/lps/{{lpId}}\",\n    \"operations\": [\n    \"buy\",\n    \"credit-delegates\",\n    \"credits\",\n    \"debits\",\n    \"gift\",\n    \"member-details\",\n    \"mv-delegates\",\n    \"mvs\",\n    \"payments\",\n    \"reversals\",\n    \"transfer\"\n    ]\n}"
						},
						"url": {
							"raw": "{{url}}/apps/{{appId}}/live-permissions/",
							"host": [
								"{{url}}"
							],
							"path": [
								"apps",
								"{{appId}}",
								"live-permissions",
								""
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Modify Live Permissions for App on LP",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"tests['Successful POST'] = responseCode.code == 201;",
									"",
									"var responseData = JSON.parse(responseBody);",
									"",
									"tests['Operations set length'] = responseData.operations.length == 4;",
									"tests['Operations set'] = responseData.operations.intersect(",
									"    [",
									"    \"member-details\",",
									"    \"mvs\",",
									"    \"debits\",",
									"    \"credits\"",
									"    ]).length == 4;"
								]
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "PATCH",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"operations\": [\n        \"member-details\",\n        \"mvs\",\n        \"debits\",\n        \"credits\"\n    ]\n}"
						},
						"url": {
							"raw": "{{url}}/apps/{{appId}}/live-permissions/{{lpId}}",
							"host": [
								"{{url}}"
							],
							"path": [
								"apps",
								"{{appId}}",
								"live-permissions",
								"{{lpId}}"
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Delete Live Permissions for App on LP",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"tests['Successful DELETE'] = responseCode.code == 204;"
								]
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json",
								"disabled": true
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{url}}/apps/{{appId}}/live-permissions/{{livePermissionsId}}",
							"host": [
								"{{url}}"
							],
							"path": [
								"apps",
								"{{appId}}",
								"live-permissions",
								"{{livePermissionsId}}"
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Get Account Permissions for App",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"tests['Successful GET'] = responseCode.code == 200;"
								]
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{url}}/apps/{{appId}}/account-permissions",
							"host": [
								"{{url}}"
							],
							"path": [
								"apps",
								"{{appId}}",
								"account-permissions"
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Update Account Permissions for App",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"tests['Successful GET'] = responseCode.code == 200;"
								]
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"admin\": [],\n  \"reports\": [],\n  \"support\": []\n}"
						},
						"url": {
							"raw": "{{url}}/apps/{{appId}}/account-permissions",
							"host": [
								"{{url}}"
							],
							"path": [
								"apps",
								"{{appId}}",
								"account-permissions"
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Get apps by Mac Key Id",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json",
								"disabled": true
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{url}}/apps/?limit=100&macKeyIdentifier={{macKeyIdentifier}}",
							"host": [
								"{{url}}"
							],
							"path": [
								"apps",
								""
							],
							"query": [
								{
									"key": "limit",
									"value": "100",
									"equals": true
								},
								{
									"key": "macKeyIdentifier",
									"value": "{{macKeyIdentifier}}",
									"equals": true
								}
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Get apps by name",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json",
								"disabled": true
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{url}}/apps/?limit=100&q=name:{{appName}}",
							"host": [
								"{{url}}"
							],
							"path": [
								"apps",
								""
							],
							"query": [
								{
									"key": "limit",
									"value": "100",
									"equals": true
								},
								{
									"key": "q",
									"value": "name:{{appName}}",
									"equals": true
								}
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Get apps",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json",
								"disabled": true
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{url}}/apps/?limit=100&q=name:{{appName}}",
							"host": [
								"{{url}}"
							],
							"path": [
								"apps",
								""
							],
							"query": [
								{
									"key": "limit",
									"value": "100",
									"equals": true
								},
								{
									"key": "q",
									"value": "name:{{appName}}",
									"equals": true
								}
							]
						},
						"description": ""
					},
					"response": []
				}
			]
		},
		{
			"name": "Credit",
			"description": "",
			"item": [
				{
					"name": "Get Credit details",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							}
						],
						"body": {},
						"url": {
							"raw": "{{url}}/lps/{{lpId}}/credits/{{creditId}}",
							"host": [
								"{{url}}"
							],
							"path": [
								"lps",
								"{{lpId}}",
								"credits",
								"{{creditId}}"
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Create Credit",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"amount\": 1,\n  \"memberValidation\": \"{{mv}}\",\n  \"optional:pic\": \"{{pic}}\",\n  \"optional:creditType:base,bonus,combinedBaseBonus\": \"\"\n}"
						},
						"url": {
							"raw": "{{url}}/lps/{{lpId}}/credits/",
							"host": [
								"{{url}}"
							],
							"path": [
								"lps",
								"{{lpId}}",
								"credits",
								""
							]
						},
						"description": ""
					},
					"response": []
				}
			]
		},
		{
			"name": "Credit Order",
			"description": "",
			"item": [
				{
					"name": "Create MV",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"tests['Successful POST'] = responseCode.code === 201;",
									"",
									"var responseData = JSON.parse(responseBody);",
									"postman.setEnvironmentVariable('MV', responseData.links.self.href);",
									"postman.setEnvironmentVariable('MVId', responseData.links.self.href.match(/(?!.*\\/).*/)[0]);",
									"postman.setEnvironmentVariable('loyaltyProgram', responseData.loyaltyProgram);",
									"",
									"tests['Has MV'] = /(?!.*\\/)[a-z0-9-]+/i.test(environment.MV);",
									"tests['Has MVId'] = typeof environment.MVId !== 'undefined';",
									"tests['Has LP'] = /(?!.*\\/)[a-z0-9-]+/i.test(environment.loyaltyProgram);",
									"tests['Has correct lpId'] = environment.loyaltyProgram.endsWith(environment.lpId);"
								]
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"firstName\": \"John\",\n  \"lastName\": \"Smith\",\n  \"memberId\": \"EIFzHa9giX\"\n}"
						},
						"url": {
							"raw": "{{url}}/lps/{{lpId}}/mvs/",
							"host": [
								"{{url}}"
							],
							"path": [
								"lps",
								"{{lpId}}",
								"mvs",
								""
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Create Order",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"tests['Successful POST'] = responseCode.code === 201;",
									"",
									"var responseData = JSON.parse(responseBody);",
									"postman.setEnvironmentVariable('order', responseData.links.self.href);",
									"postman.setEnvironmentVariable('orderId', responseData.links.self.href.match(/(?!.*\\/).*/)[0]);",
									"",
									"tests['Has order'] = /(?!.*\\/)[a-z0-9-]+/i.test(environment.order);",
									"tests['Has orderId'] = typeof environment.orderId !== 'undefined';"
								]
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "content-type",
								"value": "application/json"
							},
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"data\": {\n    \"clientIpAddress\": \"{{clientIpAddress}}\",\n    \"clientUserAgent\": \"{{clientUserAgent}}\",\n    \"language\": \"{{language}}\",\n    \"orderDetails\": {\n      \"basePoints\": 1234,\n      \"loyaltyProgram\": \"{{loyaltyProgram}}\"\n    },\n    \"user\": {\n      \"email\": \"jsmith@example.com\",\n      \"firstName\": \"John\",\n      \"lastName\": \"Smith\",\n      \"memberId\": \"EIFzHa9giX\",\n      \"memberValidation\": \"{{MV}}\"\n    }\n  },\n  \"orderType\": \"EXCHANGE_CREDIT\"\n}"
						},
						"url": {
							"raw": "{{url}}/orders/",
							"host": [
								"{{url}}"
							],
							"path": [
								"orders",
								""
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Add Order to MV",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"tests['Successful PATCH'] = responseCode.code === 200;",
									"",
									"var responseData = JSON.parse(responseBody);",
									"",
									"tests['Added order to MV'] = responseData.order === postman.getEnvironmentVariable('order');"
								]
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "PATCH",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"order\": \"{{order}}\"\n}"
						},
						"url": {
							"raw": "{{url}}/lps/{{lpId}}/mvs/{{MVId}}",
							"host": [
								"{{url}}"
							],
							"path": [
								"lps",
								"{{lpId}}",
								"mvs",
								"{{MVId}}"
							]
						},
						"description": "Add an order to an MV."
					},
					"response": []
				},
				{
					"name": "Create and add Credit to MV",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"tests['Successful POST'] = responseCode.code === 201;",
									"",
									"var responseData = JSON.parse(responseBody);",
									"",
									"tests['Successful Credit'] = responseData.status === 'success';",
									"tests['Type is Credit'] = responseData.status === 'credit';",
									"tests['Has transactionId'] = /[0-9]+/.test(responseData.transactionId);"
								]
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"amount\": 2000,\n  \"memberValidation\": \"{{MV}}\"\n}"
						},
						"url": {
							"raw": "{{url}}/lps/{{lpId}}/credits/",
							"host": [
								"{{url}}"
							],
							"path": [
								"lps",
								"{{lpId}}",
								"credits",
								""
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Modify Order status",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"tests['Successful POST'] = responseCode.code === 200;",
									"",
									"var responseData = JSON.parse(responseBody);",
									"tests['Order is complete'] = responseData.status === 'complete';",
									"tests['Updates count'] = responseData.updates.length === 2;"
								]
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "PATCH",
						"header": [
							{
								"key": "content-type",
								"value": "application/json"
							},
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"status\": \"complete\"\n}"
						},
						"url": {
							"raw": "{{url}}/orders/{{orderId}}",
							"host": [
								"{{url}}"
							],
							"path": [
								"orders",
								"{{orderId}}"
							]
						},
						"description": "Update the order status."
					},
					"response": []
				}
			]
		},
		{
			"name": "Debit Order (TODO)",
			"description": "",
			"item": [
				{
					"name": "Create MV",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"tests['Successful POST'] = responseCode.code === 201;",
									"",
									"var responseData = JSON.parse(responseBody);",
									"postman.setEnvironmentVariable('MV', responseData.links.self.href);",
									"postman.setEnvironmentVariable('MVId', responseData.links.self.href.match(/(?!.*\\/).*/)[0]);",
									"postman.setEnvironmentVariable('loyaltyProgram', responseData.loyaltyProgram);",
									"",
									"tests['Has MV'] = /(?!.*\\/)[a-z0-9-]+/i.test(environment.MV);",
									"tests['Has MVId'] = typeof environment.MVId !== 'undefined';",
									"tests['Has LP'] = /(?!.*\\/)[a-z0-9-]+/i.test(environment.loyaltyProgram);",
									"tests['Has correct lpId'] = environment.loyaltyProgram.endsWith(environment.lpId);"
								]
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = CryptoJS.lib.WordArray.random(8);",
									"        return CryptoJS.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = CryptoJS.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = CryptoJS.enc.Base64.parse(translatedSecret),",
									"            hmac = CryptoJS.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return CryptoJS.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            urlReader = document.createElement('a'),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        urlReader.href = substituteEnvVars(request.url);",
									"",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            urlReader.pathname,",
									"            urlReader.hostname,",
									"            urlReader.port || urlReader.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"postman.setEnvironmentVariable('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"firstName\": \"John\",\n  \"lastName\": \"Smith\",\n  \"memberId\": \"EIFzHa9giX\"\n}"
						},
						"url": {
							"raw": "{{url}}/lps/{{lpId}}/mvs/",
							"host": [
								"{{url}}"
							],
							"path": [
								"lps",
								"{{lpId}}",
								"mvs",
								""
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Create Order",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"tests['Successful POST'] = responseCode.code === 201;",
									"",
									"var responseData = JSON.parse(responseBody);",
									"postman.setEnvironmentVariable('order', responseData.links.self.href);",
									"postman.setEnvironmentVariable('orderId', responseData.links.self.href.match(/(?!.*\\/).*/)[0]);",
									"",
									"tests['Has order'] = /(?!.*\\/)[a-z0-9-]+/i.test(environment.order);",
									"tests['Has orderId'] = typeof environment.orderId !== 'undefined';"
								]
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = CryptoJS.lib.WordArray.random(8);",
									"        return CryptoJS.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = CryptoJS.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = CryptoJS.enc.Base64.parse(translatedSecret),",
									"            hmac = CryptoJS.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return CryptoJS.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            urlReader = document.createElement('a'),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        urlReader.href = substituteEnvVars(request.url);",
									"",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            urlReader.pathname,",
									"            urlReader.hostname,",
									"            urlReader.port || urlReader.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"postman.setEnvironmentVariable('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "content-type",
								"value": "application/json"
							},
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"data\": {\n    \"clientIpAddress\": \"{{clientIpAddress}}\",\n    \"clientUserAgent\": \"{{clientUserAgent}}\",\n    \"language\": \"{{language}}\",\n    \"orderDetails\": {\n      \"basePoints\": 1234,\n      \"loyaltyProgram\": \"{{loyaltyProgram}}\"\n    },\n    \"user\": {\n      \"email\": \"jsmith@example.com\",\n      \"firstName\": \"John\",\n      \"lastName\": \"Smith\",\n      \"memberId\": \"EIFzHa9giX\",\n      \"memberValidation\": \"{{MV}}\"\n    }\n  },\n  \"orderType\": \"EXCHANGE_CREDIT\"\n}"
						},
						"url": {
							"raw": "{{url}}/orders/",
							"host": [
								"{{url}}"
							],
							"path": [
								"orders",
								""
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Add Order to MV",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"tests['Successful PATCH'] = responseCode.code === 200;",
									"",
									"var responseData = JSON.parse(responseBody);",
									"",
									"tests['Added order to MV'] = responseData.order === postman.getEnvironmentVariable('order');"
								]
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = CryptoJS.lib.WordArray.random(8);",
									"        return CryptoJS.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = CryptoJS.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = CryptoJS.enc.Base64.parse(translatedSecret),",
									"            hmac = CryptoJS.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return CryptoJS.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            urlReader = document.createElement('a'),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        urlReader.href = substituteEnvVars(request.url);",
									"",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            urlReader.pathname,",
									"            urlReader.hostname,",
									"            urlReader.port || urlReader.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"postman.setEnvironmentVariable('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "PATCH",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"order\": \"{{order}}\"\n}"
						},
						"url": {
							"raw": "{{url}}/lps/{{lpId}}/mvs/{{MVId}}",
							"host": [
								"{{url}}"
							],
							"path": [
								"lps",
								"{{lpId}}",
								"mvs",
								"{{MVId}}"
							]
						},
						"description": "Add an order to an MV."
					},
					"response": []
				},
				{
					"name": "Create and add Credit to MV",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"tests['Successful POST'] = responseCode.code === 201;",
									"",
									"var responseData = JSON.parse(responseBody);",
									"",
									"tests['Successful Credit'] = responseData.status === 'success';",
									"tests['Type is Credit'] = responseData.status === 'credit';",
									"tests['Has transactionId'] = /[0-9]+/.test(responseData.transactionId);"
								]
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = CryptoJS.lib.WordArray.random(8);",
									"        return CryptoJS.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = CryptoJS.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = CryptoJS.enc.Base64.parse(translatedSecret),",
									"            hmac = CryptoJS.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return CryptoJS.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            urlReader = document.createElement('a'),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        urlReader.href = substituteEnvVars(request.url);",
									"",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            urlReader.pathname,",
									"            urlReader.hostname,",
									"            urlReader.port || urlReader.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"postman.setEnvironmentVariable('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"amount\": 2000,\n  \"memberValidation\": \"{{MV}}\"\n}"
						},
						"url": {
							"raw": "{{url}}/lps/{{lpId}}/credits/",
							"host": [
								"{{url}}"
							],
							"path": [
								"lps",
								"{{lpId}}",
								"credits",
								""
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Update Order status",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"tests['Successful POST'] = responseCode.code === 200;",
									"",
									"var responseData = JSON.parse(responseBody);",
									"tests['Order is complete'] = responseData.status === 'complete';",
									"tests['Updates count'] = responseData.updates.length === 2;"
								]
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = CryptoJS.lib.WordArray.random(8);",
									"        return CryptoJS.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = CryptoJS.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = CryptoJS.enc.Base64.parse(translatedSecret),",
									"            hmac = CryptoJS.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return CryptoJS.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            urlReader = document.createElement('a'),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        urlReader.href = substituteEnvVars(request.url);",
									"",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            urlReader.pathname,",
									"            urlReader.hostname,",
									"            urlReader.port || urlReader.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"postman.setEnvironmentVariable('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "PATCH",
						"header": [
							{
								"key": "content-type",
								"value": "application/json"
							},
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"status\": \"complete\"\n}"
						},
						"url": {
							"raw": "{{url}}/orders/{{orderId}}",
							"host": [
								"{{url}}"
							],
							"path": [
								"orders",
								"{{orderId}}"
							]
						},
						"description": "Update the order status."
					},
					"response": []
				}
			]
		},
		{
			"name": "LPs",
			"description": "",
			"item": [
				{
					"name": "MVs",
					"description": "",
					"item": [
						{
							"name": "Get MVs",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"tests['Successful POST'] = responseCode.code === 200;"
										]
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"let url = require('url'),",
											"    crypto = require('crypto-js');",
											"",
											"var substituteEnvVars = function (varStr) {",
											"    var match;",
											"    ",
											"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
											"        if (!Object.has(environment, match[1])) {",
											"            continue;",
											"        }",
											"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
											"        varStr = varStr.replace(envVar, environment[match[1]]);",
											"    }",
											"    ",
											"    return varStr;",
											"};",
											"",
											"var BigMac = function () {",
											"    ",
											"    var generateNonce = function () {",
											"        var wordArray = crypto.lib.WordArray.random(8);",
											"        return crypto.enc.Base64.stringify(wordArray);",
											"    };",
											"    ",
											"    var generateExt = function (contentType, payload) {",
											"        var extension = '';",
											"        if (contentType && payload) {",
											"            var hasher = crypto.algo.SHA1.create();",
											"            ",
											"            hasher.update(contentType);",
											"            hasher.update(payload);",
											"            ",
											"            extension = hasher.finalize().toString();",
											"        }",
											"        return extension;",
											"    };",
											"    ",
											"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
											"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
											"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
											"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
											"        return crypto.enc.Base64.stringify(hmac);",
											"    };",
											"    ",
											"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
											"        var ts = Math.floor((new Date()).getTime() / 1000),",
											"            reqUrl = url.parse(substituteEnvVars(request.url)),",
											"            nonce = generateNonce(),",
											"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
											"  ",
											"        var normalizedRequestString = [",
											"            ts,",
											"            nonce,",
											"            request.method,",
											"            reqUrl.pathname,",
											"            reqUrl.hostname,",
											"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
											"            extension",
											"            ].join('\\n') + '\\n';",
											"",
											"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
											"",
											"        return 'MAC id=\"' + keyId +",
											"            '\", ts=\"' + ts +",
											"            '\", nonce=\"' + nonce +",
											"            '\", ext=\"' + extension +",
											"            '\", mac=\"' + mac + '\"';",
											"    };",
											"    ",
											"    return {",
											"        generateAuthHeader: generateAuthHeader",
											"    };",
											"}();",
											"",
											"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
											"    environment.macKeyId, environment.macKey, request));",
											"",
											"var now = new Date(),",
											"    anHourAgo = new Date(now);",
											"anHourAgo.setHours(anHourAgo.getHours() - 1);",
											"postman.setEnvironmentVariable('startCreatedAt', anHourAgo.toISOString().replace(/Z$/, '000Z'));",
											"postman.setEnvironmentVariable('endCreatedAt', now.toISOString().replace(/Z$/, '000Z'));"
										]
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": "{{_AUTH_HEADER}}"
									},
									{
										"key": "content-type",
										"value": "application/json",
										"disabled": true
									}
								],
								"body": {
									"mode": "raw",
									"raw": ""
								},
								"url": {
									"raw": "{{url}}/mvs/?startCreatedAt={{startCreatedAt}}&endCreatedAt={{endCreatedAt}}&limit=10&offset=0",
									"host": [
										"{{url}}"
									],
									"path": [
										"mvs",
										""
									],
									"query": [
										{
											"key": "startCreatedAt",
											"value": "{{startCreatedAt}}",
											"equals": true
										},
										{
											"key": "endCreatedAt",
											"value": "{{endCreatedAt}}",
											"equals": true
										},
										{
											"key": "limit",
											"value": "10",
											"equals": true
										},
										{
											"key": "offset",
											"value": "0",
											"equals": true
										}
									]
								},
								"description": ""
							},
							"response": []
						},
						{
							"name": "Get MV",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"tests['Successful POST'] = responseCode.code === 200;"
										]
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"let url = require('url'),",
											"    crypto = require('crypto-js');",
											"",
											"var substituteEnvVars = function (varStr) {",
											"    var match;",
											"    ",
											"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
											"        if (!Object.has(environment, match[1])) {",
											"            continue;",
											"        }",
											"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
											"        varStr = varStr.replace(envVar, environment[match[1]]);",
											"    }",
											"    ",
											"    return varStr;",
											"};",
											"",
											"var BigMac = function () {",
											"    ",
											"    var generateNonce = function () {",
											"        var wordArray = crypto.lib.WordArray.random(8);",
											"        return crypto.enc.Base64.stringify(wordArray);",
											"    };",
											"    ",
											"    var generateExt = function (contentType, payload) {",
											"        var extension = '';",
											"        if (contentType && payload) {",
											"            var hasher = crypto.algo.SHA1.create();",
											"            ",
											"            hasher.update(contentType);",
											"            hasher.update(payload);",
											"            ",
											"            extension = hasher.finalize().toString();",
											"        }",
											"        return extension;",
											"    };",
											"    ",
											"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
											"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
											"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
											"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
											"        return crypto.enc.Base64.stringify(hmac);",
											"    };",
											"    ",
											"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
											"        var ts = Math.floor((new Date()).getTime() / 1000),",
											"            reqUrl = url.parse(substituteEnvVars(request.url)),",
											"            nonce = generateNonce(),",
											"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
											"  ",
											"        var normalizedRequestString = [",
											"            ts,",
											"            nonce,",
											"            request.method,",
											"            reqUrl.pathname,",
											"            reqUrl.hostname,",
											"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
											"            extension",
											"            ].join('\\n') + '\\n';",
											"",
											"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
											"",
											"        return 'MAC id=\"' + keyId +",
											"            '\", ts=\"' + ts +",
											"            '\", nonce=\"' + nonce +",
											"            '\", ext=\"' + extension +",
											"            '\", mac=\"' + mac + '\"';",
											"    };",
											"    ",
											"    return {",
											"        generateAuthHeader: generateAuthHeader",
											"    };",
											"}();",
											"",
											"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
											"    environment.macKeyId, environment.macKey, request));"
										]
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": "{{_AUTH_HEADER}}"
									},
									{
										"key": "content-type",
										"value": "application/json",
										"disabled": true
									}
								],
								"body": {
									"mode": "raw",
									"raw": ""
								},
								"url": {
									"raw": "{{url}}/lps/{{lpId}}/mvs/{{mvId}}",
									"host": [
										"{{url}}"
									],
									"path": [
										"lps",
										"{{lpId}}",
										"mvs",
										"{{mvId}}"
									]
								},
								"description": ""
							},
							"response": []
						},
						{
							"name": "Create MV",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"tests['Successful POST'] = responseCode.code === 201;",
											"",
											"var responseData = JSON.parse(responseBody);",
											"postman.setEnvironmentVariable('MV', responseData.links.self.href);",
											"postman.setEnvironmentVariable('MVId', responseData.links.self.href.match(/(?!.*\\/).*/)[0]);",
											"postman.setEnvironmentVariable('loyaltyProgram', responseData.loyaltyProgram);",
											"",
											"tests['Has MV'] = /(?!.*\\/)[a-z0-9-]+/i.test(environment.MV);",
											"tests['Has MVId'] = typeof environment.MVId !== 'undefined';",
											"tests['Has LP'] = /(?!.*\\/)[a-z0-9-]+/i.test(environment.loyaltyProgram);",
											"tests['Has correct lpId'] = environment.loyaltyProgram.endsWith(environment.lpId);"
										]
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"let url = require('url'),",
											"    crypto = require('crypto-js');",
											"",
											"var substituteEnvVars = function (varStr) {",
											"    var match;",
											"    ",
											"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
											"        if (!Object.has(environment, match[1])) {",
											"            continue;",
											"        }",
											"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
											"        varStr = varStr.replace(envVar, environment[match[1]]);",
											"    }",
											"    ",
											"    return varStr;",
											"};",
											"",
											"var BigMac = function () {",
											"    ",
											"    var generateNonce = function () {",
											"        var wordArray = crypto.lib.WordArray.random(8);",
											"        return crypto.enc.Base64.stringify(wordArray);",
											"    };",
											"    ",
											"    var generateExt = function (contentType, payload) {",
											"        var extension = '';",
											"        if (contentType && payload) {",
											"            var hasher = crypto.algo.SHA1.create();",
											"            ",
											"            hasher.update(contentType);",
											"            hasher.update(payload);",
											"            ",
											"            extension = hasher.finalize().toString();",
											"        }",
											"        return extension;",
											"    };",
											"    ",
											"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
											"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
											"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
											"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
											"        return crypto.enc.Base64.stringify(hmac);",
											"    };",
											"    ",
											"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
											"        var ts = Math.floor((new Date()).getTime() / 1000),",
											"            reqUrl = url.parse(substituteEnvVars(request.url)),",
											"            nonce = generateNonce(),",
											"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
											"  ",
											"        var normalizedRequestString = [",
											"            ts,",
											"            nonce,",
											"            request.method,",
											"            reqUrl.pathname,",
											"            reqUrl.hostname,",
											"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
											"            extension",
											"            ].join('\\n') + '\\n';",
											"",
											"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
											"",
											"        return 'MAC id=\"' + keyId +",
											"            '\", ts=\"' + ts +",
											"            '\", nonce=\"' + nonce +",
											"            '\", ext=\"' + extension +",
											"            '\", mac=\"' + mac + '\"';",
											"    };",
											"    ",
											"    return {",
											"        generateAuthHeader: generateAuthHeader",
											"    };",
											"}();",
											"",
											"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
											"    environment.macKeyId, environment.macKey, request));"
										]
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Authorization",
										"value": "{{_AUTH_HEADER}}"
									},
									{
										"key": "content-type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"firstName\": \"John\",\n  \"lastName\": \"Smith\",\n  \"memberId\": \"EIFzHa9giX\"\n}"
								},
								"url": {
									"raw": "{{url}}/lps/{{lpId}}/mvs/",
									"host": [
										"{{url}}"
									],
									"path": [
										"lps",
										"{{lpId}}",
										"mvs",
										""
									]
								},
								"description": ""
							},
							"response": []
						},
						{
							"name": "Get MV delegate",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"tests['Successful POST'] = responseCode.code === 200;"
										]
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"let url = require('url'),",
											"    crypto = require('crypto-js');",
											"",
											"var substituteEnvVars = function (varStr) {",
											"    var match;",
											"    ",
											"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
											"        if (!Object.has(environment, match[1])) {",
											"            continue;",
											"        }",
											"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
											"        varStr = varStr.replace(envVar, environment[match[1]]);",
											"    }",
											"    ",
											"    return varStr;",
											"};",
											"",
											"var BigMac = function () {",
											"    ",
											"    var generateNonce = function () {",
											"        var wordArray = crypto.lib.WordArray.random(8);",
											"        return crypto.enc.Base64.stringify(wordArray);",
											"    };",
											"    ",
											"    var generateExt = function (contentType, payload) {",
											"        var extension = '';",
											"        if (contentType && payload) {",
											"            var hasher = crypto.algo.SHA1.create();",
											"            ",
											"            hasher.update(contentType);",
											"            hasher.update(payload);",
											"            ",
											"            extension = hasher.finalize().toString();",
											"        }",
											"        return extension;",
											"    };",
											"    ",
											"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
											"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
											"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
											"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
											"        return crypto.enc.Base64.stringify(hmac);",
											"    };",
											"    ",
											"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
											"        var ts = Math.floor((new Date()).getTime() / 1000),",
											"            reqUrl = url.parse(substituteEnvVars(request.url)),",
											"            nonce = generateNonce(),",
											"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
											"  ",
											"        var normalizedRequestString = [",
											"            ts,",
											"            nonce,",
											"            request.method,",
											"            reqUrl.pathname,",
											"            reqUrl.hostname,",
											"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
											"            extension",
											"            ].join('\\n') + '\\n';",
											"",
											"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
											"",
											"        return 'MAC id=\"' + keyId +",
											"            '\", ts=\"' + ts +",
											"            '\", nonce=\"' + nonce +",
											"            '\", ext=\"' + extension +",
											"            '\", mac=\"' + mac + '\"';",
											"    };",
											"    ",
											"    return {",
											"        generateAuthHeader: generateAuthHeader",
											"    };",
											"}();",
											"",
											"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
											"    environment.macKeyId, environment.macKey, request));"
										]
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": "{{_AUTH_HEADER}}"
									},
									{
										"key": "content-type",
										"value": "application/json",
										"disabled": true
									}
								],
								"body": {
									"mode": "raw",
									"raw": ""
								},
								"url": {
									"raw": "{{url}}/lps/{{lpId}}/mv-delegates/{{mvDelegateId}}",
									"host": [
										"{{url}}"
									],
									"path": [
										"lps",
										"{{lpId}}",
										"mv-delegates",
										"{{mvDelegateId}}"
									]
								},
								"description": ""
							},
							"response": []
						},
						{
							"name": "Create MV delegate",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"tests['Successful POST'] = responseCode.code === 200;",
											"",
											"var responseData = JSON.parse(responseBody);",
											"postman.setEnvironmentVariable('mv', responseData.memberValidation);",
											"postman.setEnvironmentVariable('mvId', responseData.memberValidation.match(/(?!.*\\/).*/)[0]);",
											"postman.setEnvironmentVariable('mvDelegate', responseData.links.self.href);",
											"postman.setEnvironmentVariable('mvDelegateId', responseData.links.self.href.match(/(?!.*\\/).*/)[0]);"
										]
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"let url = require('url'),",
											"    crypto = require('crypto-js');",
											"",
											"var substituteEnvVars = function (varStr) {",
											"    var match;",
											"    ",
											"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
											"        if (!Object.has(environment, match[1])) {",
											"            continue;",
											"        }",
											"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
											"        varStr = varStr.replace(envVar, environment[match[1]]);",
											"    }",
											"    ",
											"    return varStr;",
											"};",
											"",
											"var BigMac = function () {",
											"    ",
											"    var generateNonce = function () {",
											"        var wordArray = crypto.lib.WordArray.random(8);",
											"        return crypto.enc.Base64.stringify(wordArray);",
											"    };",
											"    ",
											"    var generateExt = function (contentType, payload) {",
											"        var extension = '';",
											"        if (contentType && payload) {",
											"            var hasher = crypto.algo.SHA1.create();",
											"            ",
											"            hasher.update(contentType);",
											"            hasher.update(payload);",
											"            ",
											"            extension = hasher.finalize().toString();",
											"        }",
											"        return extension;",
											"    };",
											"    ",
											"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
											"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
											"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
											"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
											"        return crypto.enc.Base64.stringify(hmac);",
											"    };",
											"    ",
											"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
											"        var ts = Math.floor((new Date()).getTime() / 1000),",
											"            reqUrl = url.parse(substituteEnvVars(request.url)),",
											"            nonce = generateNonce(),",
											"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
											"  ",
											"        var normalizedRequestString = [",
											"            ts,",
											"            nonce,",
											"            request.method,",
											"            reqUrl.pathname,",
											"            reqUrl.hostname,",
											"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
											"            extension",
											"            ].join('\\n') + '\\n';",
											"",
											"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
											"",
											"        return 'MAC id=\"' + keyId +",
											"            '\", ts=\"' + ts +",
											"            '\", nonce=\"' + nonce +",
											"            '\", ext=\"' + extension +",
											"            '\", mac=\"' + mac + '\"';",
											"    };",
											"    ",
											"    return {",
											"        generateAuthHeader: generateAuthHeader",
											"    };",
											"}();",
											"",
											"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
											"    environment.macKeyId, environment.macKey, request));"
										]
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Authorization",
										"value": "{{_AUTH_HEADER}}"
									},
									{
										"key": "content-type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"application\": \"{{url}}/apps/{{appId}}\",\n  \"memberValidation\": {\n    \"identifyingFactors\": {\n      \"lastName\": \"\",\n      \"memberId\": \"\"\n    },\n    \"authenticatingFactors\": {\n      \"password\": \"\"\n    }\n  },\n  \"memberValidationResponse\": {\n    \"balance\": 2000\n  }\n}"
								},
								"url": {
									"raw": "{{url}}/lps/{{lpId}}/mv-delegates/",
									"host": [
										"{{url}}"
									],
									"path": [
										"lps",
										"{{lpId}}",
										"mv-delegates",
										""
									]
								},
								"description": ""
							},
							"response": []
						},
						{
							"name": "Get member details",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"tests['Successful POST'] = responseCode.code === 200;"
										]
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"let url = require('url'),",
											"    crypto = require('crypto-js');",
											"",
											"var substituteEnvVars = function (varStr) {",
											"    var match;",
											"    ",
											"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
											"        if (!Object.has(environment, match[1])) {",
											"            continue;",
											"        }",
											"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
											"        varStr = varStr.replace(envVar, environment[match[1]]);",
											"    }",
											"    ",
											"    return varStr;",
											"};",
											"",
											"var BigMac = function () {",
											"    ",
											"    var generateNonce = function () {",
											"        var wordArray = crypto.lib.WordArray.random(8);",
											"        return crypto.enc.Base64.stringify(wordArray);",
											"    };",
											"    ",
											"    var generateExt = function (contentType, payload) {",
											"        var extension = '';",
											"        if (contentType && payload) {",
											"            var hasher = crypto.algo.SHA1.create();",
											"            ",
											"            hasher.update(contentType);",
											"            hasher.update(payload);",
											"            ",
											"            extension = hasher.finalize().toString();",
											"        }",
											"        return extension;",
											"    };",
											"    ",
											"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
											"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
											"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
											"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
											"        return crypto.enc.Base64.stringify(hmac);",
											"    };",
											"    ",
											"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
											"        var ts = Math.floor((new Date()).getTime() / 1000),",
											"            reqUrl = url.parse(substituteEnvVars(request.url)),",
											"            nonce = generateNonce(),",
											"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
											"  ",
											"        var normalizedRequestString = [",
											"            ts,",
											"            nonce,",
											"            request.method,",
											"            reqUrl.pathname,",
											"            reqUrl.hostname,",
											"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
											"            extension",
											"            ].join('\\n') + '\\n';",
											"",
											"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
											"",
											"        return 'MAC id=\"' + keyId +",
											"            '\", ts=\"' + ts +",
											"            '\", nonce=\"' + nonce +",
											"            '\", ext=\"' + extension +",
											"            '\", mac=\"' + mac + '\"';",
											"    };",
											"    ",
											"    return {",
											"        generateAuthHeader: generateAuthHeader",
											"    };",
											"}();",
											"",
											"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
											"    environment.macKeyId, environment.macKey, request));"
										]
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": "{{_AUTH_HEADER}}"
									},
									{
										"key": "content-type",
										"value": "application/json",
										"disabled": true
									}
								],
								"body": {
									"mode": "raw",
									"raw": ""
								},
								"url": {
									"raw": "{{url}}/lps/{{lpId}}/mvs/{{MVId}}/member-details",
									"host": [
										"{{url}}"
									],
									"path": [
										"lps",
										"{{lpId}}",
										"mvs",
										"{{MVId}}",
										"member-details"
									]
								},
								"description": ""
							},
							"response": []
						},
						{
							"name": "Get LP MV Request Schema",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"let url = require('url'),",
											"    crypto = require('crypto-js');",
											"",
											"var substituteEnvVars = function (varStr) {",
											"    var match;",
											"    ",
											"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
											"        if (!Object.has(environment, match[1])) {",
											"            continue;",
											"        }",
											"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
											"        varStr = varStr.replace(envVar, environment[match[1]]);",
											"    }",
											"    ",
											"    return varStr;",
											"};",
											"",
											"var BigMac = function () {",
											"    ",
											"    var generateNonce = function () {",
											"        var wordArray = crypto.lib.WordArray.random(8);",
											"        return crypto.enc.Base64.stringify(wordArray);",
											"    };",
											"    ",
											"    var generateExt = function (contentType, payload) {",
											"        var extension = '';",
											"        if (contentType && payload) {",
											"            var hasher = crypto.algo.SHA1.create();",
											"            ",
											"            hasher.update(contentType);",
											"            hasher.update(payload);",
											"            ",
											"            extension = hasher.finalize().toString();",
											"        }",
											"        return extension;",
											"    };",
											"    ",
											"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
											"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
											"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
											"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
											"        return crypto.enc.Base64.stringify(hmac);",
											"    };",
											"    ",
											"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
											"        var ts = Math.floor((new Date()).getTime() / 1000),",
											"            reqUrl = url.parse(substituteEnvVars(request.url)),",
											"            nonce = generateNonce(),",
											"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
											"  ",
											"        var normalizedRequestString = [",
											"            ts,",
											"            nonce,",
											"            request.method,",
											"            reqUrl.pathname,",
											"            reqUrl.hostname,",
											"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
											"            extension",
											"            ].join('\\n') + '\\n';",
											"",
											"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
											"",
											"        return 'MAC id=\"' + keyId +",
											"            '\", ts=\"' + ts +",
											"            '\", nonce=\"' + nonce +",
											"            '\", ext=\"' + extension +",
											"            '\", mac=\"' + mac + '\"';",
											"    };",
											"    ",
											"    return {",
											"        generateAuthHeader: generateAuthHeader",
											"    };",
											"}();",
											"",
											"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
											"    environment.macKeyId, environment.macKey, request));"
										]
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": "{{_AUTH_HEADER}}"
									},
									{
										"key": "content-type",
										"value": "application/json",
										"disabled": true
									}
								],
								"body": {
									"mode": "raw",
									"raw": ""
								},
								"url": {
									"raw": "{{url}}/lps/{{lpId}}/mvs/metadata/schema",
									"host": [
										"{{url}}"
									],
									"path": [
										"lps",
										"{{lpId}}",
										"mvs",
										"metadata",
										"schema"
									]
								},
								"description": ""
							},
							"response": []
						},
						{
							"name": "Update LP MV Request Schema",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"let url = require('url'),",
											"    crypto = require('crypto-js');",
											"",
											"var substituteEnvVars = function (varStr) {",
											"    var match;",
											"    ",
											"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
											"        if (!Object.has(environment, match[1])) {",
											"            continue;",
											"        }",
											"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
											"        varStr = varStr.replace(envVar, environment[match[1]]);",
											"    }",
											"    ",
											"    return varStr;",
											"};",
											"",
											"var BigMac = function () {",
											"    ",
											"    var generateNonce = function () {",
											"        var wordArray = crypto.lib.WordArray.random(8);",
											"        return crypto.enc.Base64.stringify(wordArray);",
											"    };",
											"    ",
											"    var generateExt = function (contentType, payload) {",
											"        var extension = '';",
											"        if (contentType && payload) {",
											"            var hasher = crypto.algo.SHA1.create();",
											"            ",
											"            hasher.update(contentType);",
											"            hasher.update(payload);",
											"            ",
											"            extension = hasher.finalize().toString();",
											"        }",
											"        return extension;",
											"    };",
											"    ",
											"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
											"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
											"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
											"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
											"        return crypto.enc.Base64.stringify(hmac);",
											"    };",
											"    ",
											"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
											"        var ts = Math.floor((new Date()).getTime() / 1000),",
											"            reqUrl = url.parse(substituteEnvVars(request.url)),",
											"            nonce = generateNonce(),",
											"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
											"  ",
											"        var normalizedRequestString = [",
											"            ts,",
											"            nonce,",
											"            request.method,",
											"            reqUrl.pathname,",
											"            reqUrl.hostname,",
											"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
											"            extension",
											"            ].join('\\n') + '\\n';",
											"",
											"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
											"",
											"        return 'MAC id=\"' + keyId +",
											"            '\", ts=\"' + ts +",
											"            '\", nonce=\"' + nonce +",
											"            '\", ext=\"' + extension +",
											"            '\", mac=\"' + mac + '\"';",
											"    };",
											"    ",
											"    return {",
											"        generateAuthHeader: generateAuthHeader",
											"    };",
											"}();",
											"",
											"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
											"    environment.macKeyId, environment.macKey, request));"
										]
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [
									{
										"key": "Authorization",
										"value": "{{_AUTH_HEADER}}"
									},
									{
										"key": "content-type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": ""
								},
								"url": {
									"raw": "{{url}}/lps/{{lpId}}/mvs/metadata/schema",
									"host": [
										"{{url}}"
									],
									"path": [
										"lps",
										"{{lpId}}",
										"mvs",
										"metadata",
										"schema"
									]
								},
								"description": ""
							},
							"response": []
						},
						{
							"name": "Get LP MV Response Schema",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"let url = require('url'),",
											"    crypto = require('crypto-js');",
											"",
											"var substituteEnvVars = function (varStr) {",
											"    var match;",
											"    ",
											"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
											"        if (!Object.has(environment, match[1])) {",
											"            continue;",
											"        }",
											"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
											"        varStr = varStr.replace(envVar, environment[match[1]]);",
											"    }",
											"    ",
											"    return varStr;",
											"};",
											"",
											"var BigMac = function () {",
											"    ",
											"    var generateNonce = function () {",
											"        var wordArray = crypto.lib.WordArray.random(8);",
											"        return crypto.enc.Base64.stringify(wordArray);",
											"    };",
											"    ",
											"    var generateExt = function (contentType, payload) {",
											"        var extension = '';",
											"        if (contentType && payload) {",
											"            var hasher = crypto.algo.SHA1.create();",
											"            ",
											"            hasher.update(contentType);",
											"            hasher.update(payload);",
											"            ",
											"            extension = hasher.finalize().toString();",
											"        }",
											"        return extension;",
											"    };",
											"    ",
											"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
											"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
											"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
											"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
											"        return crypto.enc.Base64.stringify(hmac);",
											"    };",
											"    ",
											"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
											"        var ts = Math.floor((new Date()).getTime() / 1000),",
											"            reqUrl = url.parse(substituteEnvVars(request.url)),",
											"            nonce = generateNonce(),",
											"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
											"  ",
											"        var normalizedRequestString = [",
											"            ts,",
											"            nonce,",
											"            request.method,",
											"            reqUrl.pathname,",
											"            reqUrl.hostname,",
											"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
											"            extension",
											"            ].join('\\n') + '\\n';",
											"",
											"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
											"",
											"        return 'MAC id=\"' + keyId +",
											"            '\", ts=\"' + ts +",
											"            '\", nonce=\"' + nonce +",
											"            '\", ext=\"' + extension +",
											"            '\", mac=\"' + mac + '\"';",
											"    };",
											"    ",
											"    return {",
											"        generateAuthHeader: generateAuthHeader",
											"    };",
											"}();",
											"",
											"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
											"    environment.macKeyId, environment.macKey, request));"
										]
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": "{{_AUTH_HEADER}}"
									},
									{
										"key": "content-type",
										"value": "application/json",
										"disabled": true
									}
								],
								"body": {
									"mode": "raw",
									"raw": ""
								},
								"url": {
									"raw": "{{url}}/lps/{{lpId}}/mvs/metadata/response",
									"host": [
										"{{url}}"
									],
									"path": [
										"lps",
										"{{lpId}}",
										"mvs",
										"metadata",
										"response"
									]
								},
								"description": ""
							},
							"response": []
						},
						{
							"name": "Update LP MV Response Schema",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"let url = require('url'),",
											"    crypto = require('crypto-js');",
											"",
											"var substituteEnvVars = function (varStr) {",
											"    var match;",
											"    ",
											"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
											"        if (!Object.has(environment, match[1])) {",
											"            continue;",
											"        }",
											"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
											"        varStr = varStr.replace(envVar, environment[match[1]]);",
											"    }",
											"    ",
											"    return varStr;",
											"};",
											"",
											"var BigMac = function () {",
											"    ",
											"    var generateNonce = function () {",
											"        var wordArray = crypto.lib.WordArray.random(8);",
											"        return crypto.enc.Base64.stringify(wordArray);",
											"    };",
											"    ",
											"    var generateExt = function (contentType, payload) {",
											"        var extension = '';",
											"        if (contentType && payload) {",
											"            var hasher = crypto.algo.SHA1.create();",
											"            ",
											"            hasher.update(contentType);",
											"            hasher.update(payload);",
											"            ",
											"            extension = hasher.finalize().toString();",
											"        }",
											"        return extension;",
											"    };",
											"    ",
											"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
											"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
											"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
											"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
											"        return crypto.enc.Base64.stringify(hmac);",
											"    };",
											"    ",
											"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
											"        var ts = Math.floor((new Date()).getTime() / 1000),",
											"            reqUrl = url.parse(substituteEnvVars(request.url)),",
											"            nonce = generateNonce(),",
											"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
											"  ",
											"        var normalizedRequestString = [",
											"            ts,",
											"            nonce,",
											"            request.method,",
											"            reqUrl.pathname,",
											"            reqUrl.hostname,",
											"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
											"            extension",
											"            ].join('\\n') + '\\n';",
											"",
											"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
											"",
											"        return 'MAC id=\"' + keyId +",
											"            '\", ts=\"' + ts +",
											"            '\", nonce=\"' + nonce +",
											"            '\", ext=\"' + extension +",
											"            '\", mac=\"' + mac + '\"';",
											"    };",
											"    ",
											"    return {",
											"        generateAuthHeader: generateAuthHeader",
											"    };",
											"}();",
											"",
											"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
											"    environment.macKeyId, environment.macKey, request));"
										]
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [
									{
										"key": "Authorization",
										"value": "{{_AUTH_HEADER}}"
									},
									{
										"key": "content-type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": ""
								},
								"url": {
									"raw": "{{url}}/lps/{{lpId}}/mvs/metadata/response",
									"host": [
										"{{url}}"
									],
									"path": [
										"lps",
										"{{lpId}}",
										"mvs",
										"metadata",
										"response"
									]
								},
								"description": ""
							},
							"response": []
						},
						{
							"name": "Get LP MV Sandbox Responses",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"let url = require('url'),",
											"    crypto = require('crypto-js');",
											"",
											"var substituteEnvVars = function (varStr) {",
											"    var match;",
											"    ",
											"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
											"        if (!Object.has(environment, match[1])) {",
											"            continue;",
											"        }",
											"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
											"        varStr = varStr.replace(envVar, environment[match[1]]);",
											"    }",
											"    ",
											"    return varStr;",
											"};",
											"",
											"var BigMac = function () {",
											"    ",
											"    var generateNonce = function () {",
											"        var wordArray = crypto.lib.WordArray.random(8);",
											"        return crypto.enc.Base64.stringify(wordArray);",
											"    };",
											"    ",
											"    var generateExt = function (contentType, payload) {",
											"        var extension = '';",
											"        if (contentType && payload) {",
											"            var hasher = crypto.algo.SHA1.create();",
											"            ",
											"            hasher.update(contentType);",
											"            hasher.update(payload);",
											"            ",
											"            extension = hasher.finalize().toString();",
											"        }",
											"        return extension;",
											"    };",
											"    ",
											"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
											"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
											"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
											"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
											"        return crypto.enc.Base64.stringify(hmac);",
											"    };",
											"    ",
											"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
											"        var ts = Math.floor((new Date()).getTime() / 1000),",
											"            reqUrl = url.parse(substituteEnvVars(request.url)),",
											"            nonce = generateNonce(),",
											"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
											"  ",
											"        var normalizedRequestString = [",
											"            ts,",
											"            nonce,",
											"            request.method,",
											"            reqUrl.pathname,",
											"            reqUrl.hostname,",
											"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
											"            extension",
											"            ].join('\\n') + '\\n';",
											"",
											"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
											"",
											"        return 'MAC id=\"' + keyId +",
											"            '\", ts=\"' + ts +",
											"            '\", nonce=\"' + nonce +",
											"            '\", ext=\"' + extension +",
											"            '\", mac=\"' + mac + '\"';",
											"    };",
											"    ",
											"    return {",
											"        generateAuthHeader: generateAuthHeader",
											"    };",
											"}();",
											"",
											"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
											"    environment.macKeyId, environment.macKey, request));"
										]
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": "{{_AUTH_HEADER}}"
									},
									{
										"key": "content-type",
										"value": "application/json",
										"disabled": true
									}
								],
								"body": {
									"mode": "raw",
									"raw": ""
								},
								"url": {
									"raw": "{{url}}/lps/{{lpId}}/mvs/metadata/sandbox-responses",
									"host": [
										"{{url}}"
									],
									"path": [
										"lps",
										"{{lpId}}",
										"mvs",
										"metadata",
										"sandbox-responses"
									]
								},
								"description": ""
							},
							"response": []
						},
						{
							"name": "Update LP MV Sandbox Responses",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"let url = require('url'),",
											"    crypto = require('crypto-js');",
											"",
											"var substituteEnvVars = function (varStr) {",
											"    var match;",
											"    ",
											"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
											"        if (!Object.has(environment, match[1])) {",
											"            continue;",
											"        }",
											"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
											"        varStr = varStr.replace(envVar, environment[match[1]]);",
											"    }",
											"    ",
											"    return varStr;",
											"};",
											"",
											"var BigMac = function () {",
											"    ",
											"    var generateNonce = function () {",
											"        var wordArray = crypto.lib.WordArray.random(8);",
											"        return crypto.enc.Base64.stringify(wordArray);",
											"    };",
											"    ",
											"    var generateExt = function (contentType, payload) {",
											"        var extension = '';",
											"        if (contentType && payload) {",
											"            var hasher = crypto.algo.SHA1.create();",
											"            ",
											"            hasher.update(contentType);",
											"            hasher.update(payload);",
											"            ",
											"            extension = hasher.finalize().toString();",
											"        }",
											"        return extension;",
											"    };",
											"    ",
											"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
											"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
											"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
											"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
											"        return crypto.enc.Base64.stringify(hmac);",
											"    };",
											"    ",
											"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
											"        var ts = Math.floor((new Date()).getTime() / 1000),",
											"            reqUrl = url.parse(substituteEnvVars(request.url)),",
											"            nonce = generateNonce(),",
											"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
											"  ",
											"        var normalizedRequestString = [",
											"            ts,",
											"            nonce,",
											"            request.method,",
											"            reqUrl.pathname,",
											"            reqUrl.hostname,",
											"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
											"            extension",
											"            ].join('\\n') + '\\n';",
											"",
											"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
											"",
											"        return 'MAC id=\"' + keyId +",
											"            '\", ts=\"' + ts +",
											"            '\", nonce=\"' + nonce +",
											"            '\", ext=\"' + extension +",
											"            '\", mac=\"' + mac + '\"';",
											"    };",
											"    ",
											"    return {",
											"        generateAuthHeader: generateAuthHeader",
											"    };",
											"}();",
											"",
											"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
											"    environment.macKeyId, environment.macKey, request));"
										]
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [
									{
										"key": "Authorization",
										"value": "{{_AUTH_HEADER}}"
									},
									{
										"key": "content-type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": ""
								},
								"url": {
									"raw": "{{url}}/lps/{{lpId}}/mvs/metadata/sandbox-responses",
									"host": [
										"{{url}}"
									],
									"path": [
										"lps",
										"{{lpId}}",
										"mvs",
										"metadata",
										"sandbox-responses"
									]
								},
								"description": ""
							},
							"response": []
						}
					],
					"_postman_isSubFolder": true
				},
				{
					"name": "Get LP",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json",
								"disabled": true
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{url}}/lps/{{lpId}}",
							"host": [
								"{{url}}"
							],
							"path": [
								"lps",
								"{{lpId}}"
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Get LP URLs",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json",
								"disabled": true
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{url}}/lps/{{lpId}}/urls",
							"host": [
								"{{url}}"
							],
							"path": [
								"lps",
								"{{lpId}}",
								"urls"
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Update LP URLs",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"memberValidations\": \"\",\n  \"debits\": \"\",\n  \"credits\": \"\",\n  \"moves\": \"\",\n  \"creditReversals\": \"\",\n  \"debitReversals\": \"\",\n  \"augmentedData\": \"\"\n}"
						},
						"url": {
							"raw": "{{url}}/lps/{{lpId}}/urls",
							"host": [
								"{{url}}"
							],
							"path": [
								"lps",
								"{{lpId}}",
								"urls"
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Get LP Account Permissions",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json",
								"disabled": true
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{url}}/lps/{{lpId}}/account-permissions",
							"host": [
								"{{url}}"
							],
							"path": [
								"lps",
								"{{lpId}}",
								"account-permissions"
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Update LP Account Permissions",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"admin\": [],\n  \"reports\": [],\n  \"support\": []\n}"
						},
						"url": {
							"raw": "{{url}}/lps/{{lpId}}/account-permissions",
							"host": [
								"{{url}}"
							],
							"path": [
								"lps",
								"{{lpId}}",
								"account-permissions"
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Get LPs by partnerName",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json",
								"disabled": true
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{url}}/lps/?limit=10&offset=0&partnerName={{partnerName}}",
							"host": [
								"{{url}}"
							],
							"path": [
								"lps",
								""
							],
							"query": [
								{
									"key": "limit",
									"value": "10",
									"equals": true
								},
								{
									"key": "offset",
									"value": "0",
									"equals": true
								},
								{
									"key": "partnerName",
									"value": "{{partnerName}}",
									"equals": true
								}
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Get LPs by partnerId",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json",
								"disabled": true
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{url}}/lps/?limit=10&offset=0&partnerId=\"{{partnerId}}\"",
							"host": [
								"{{url}}"
							],
							"path": [
								"lps",
								""
							],
							"query": [
								{
									"key": "limit",
									"value": "10",
									"equals": true
								},
								{
									"key": "offset",
									"value": "0",
									"equals": true
								},
								{
									"key": "partnerId",
									"value": "\"{{partnerId}}\"",
									"equals": true
								}
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Get LPs by partnerName copy",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json",
								"disabled": true
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{url}}/lps/?limit=10&offset=0&partnerName={{partnerName}}",
							"host": [
								"{{url}}"
							],
							"path": [
								"lps",
								""
							],
							"query": [
								{
									"key": "limit",
									"value": "10",
									"equals": true
								},
								{
									"key": "offset",
									"value": "0",
									"equals": true
								},
								{
									"key": "partnerName",
									"value": "{{partnerName}}",
									"equals": true
								}
							]
						},
						"description": ""
					},
					"response": []
				}
			]
		},
		{
			"name": "Orders",
			"description": "",
			"item": [
				{
					"name": "Get Order Info",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"tests['Successful POST'] = responseCode.code === 200;",
									""
								]
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "content-type",
								"value": "application/json"
							},
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{url}}/orders/{{orderId}}",
							"host": [
								"{{url}}"
							],
							"path": [
								"orders",
								"{{orderId}}"
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Get Orders",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"tests['Successful POST'] = responseCode.code === 200;"
								]
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "content-type",
								"value": "application/json",
								"disabled": true
							},
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{url}}/search/orders/?q=orderType:EXCHANGE_CREDIT",
							"host": [
								"{{url}}"
							],
							"path": [
								"search",
								"orders",
								""
							],
							"query": [
								{
									"key": "q",
									"value": "orderType:EXCHANGE_CREDIT",
									"equals": true
								}
							]
						},
						"description": "Search for orders."
					},
					"response": []
				}
			]
		},
		{
			"name": "Provisioners",
			"description": "",
			"item": [
				{
					"name": "Get Provisioner",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json",
								"disabled": true
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{url}}/provisioners/{{provisionerId}}",
							"host": [
								"{{url}}"
							],
							"path": [
								"provisioners",
								"{{provisionerId}}"
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Get Provisioner External Accounts",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json",
								"disabled": true
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{url}}/provisioners/{{provisionerId}}/external-accounts/sarah.sternfels%40points.com",
							"host": [
								"{{url}}"
							],
							"path": [
								"provisioners",
								"{{provisionerId}}",
								"external-accounts",
								"sarah.sternfels%40points.com"
							]
						},
						"description": ""
					},
					"response": []
				}
			]
		},
		{
			"name": "Roles",
			"description": "",
			"item": [
				{
					"name": "Get list of roles",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json",
								"disabled": true
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{url}}/roles/",
							"host": [
								"{{url}}"
							],
							"path": [
								"roles",
								""
							]
						},
						"description": ""
					},
					"response": []
				},
				{
					"name": "Get list of roles copy",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json",
								"disabled": true
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{url}}/roles/",
							"host": [
								"{{url}}"
							],
							"path": [
								"roles",
								""
							]
						},
						"description": ""
					},
					"response": []
				}
			]
		},
		{
			"name": "Security",
			"description": "",
			"item": [
				{
					"name": "Get Security Principal",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"let url = require('url'),",
									"    crypto = require('crypto-js');",
									"",
									"var substituteEnvVars = function (varStr) {",
									"    var match;",
									"    ",
									"    while ((match = /\\{\\{([^{}]*?)}}/g.exec(varStr)) !== null ) {",
									"        if (!Object.has(environment, match[1])) {",
									"            continue;",
									"        }",
									"        var envVar = new RegExp(RegExp.escape(match[0]), 'g');",
									"        varStr = varStr.replace(envVar, environment[match[1]]);",
									"    }",
									"    ",
									"    return varStr;",
									"};",
									"",
									"var BigMac = function () {",
									"    ",
									"    var generateNonce = function () {",
									"        var wordArray = crypto.lib.WordArray.random(8);",
									"        return crypto.enc.Base64.stringify(wordArray);",
									"    };",
									"    ",
									"    var generateExt = function (contentType, payload) {",
									"        var extension = '';",
									"        if (contentType && payload) {",
									"            var hasher = crypto.algo.SHA1.create();",
									"            ",
									"            hasher.update(contentType);",
									"            hasher.update(payload);",
									"            ",
									"            extension = hasher.finalize().toString();",
									"        }",
									"        return extension;",
									"    };",
									"    ",
									"    var generateSignature = function (sharedSecret, normalizedRequestString) {",
									"        var translatedSecret = sharedSecret.replace(/-/g, '+').replace(/_/g, '/'),",
									"            decodedSecret = crypto.enc.Base64.parse(translatedSecret),",
									"            hmac = crypto.HmacSHA1(normalizedRequestString, decodedSecret);",
									"        return crypto.enc.Base64.stringify(hmac);",
									"    };",
									"    ",
									"    var generateAuthHeader = function(keyId, sharedSecret, request) {",
									"        var ts = Math.floor((new Date()).getTime() / 1000),",
									"            reqUrl = url.parse(substituteEnvVars(request.url)),",
									"            nonce = generateNonce(),",
									"            extension = generateExt(request.headers['content-type'], substituteEnvVars(request.data));",
									"  ",
									"        var normalizedRequestString = [",
									"            ts,",
									"            nonce,",
									"            request.method,",
									"            reqUrl.pathname,",
									"            reqUrl.hostname,",
									"            reqUrl.port || reqUrl.protocol == 'https:' ? '443' : '80',",
									"            extension",
									"            ].join('\\n') + '\\n';",
									"",
									"        var mac = generateSignature(sharedSecret, normalizedRequestString);",
									"",
									"        return 'MAC id=\"' + keyId +",
									"            '\", ts=\"' + ts +",
									"            '\", nonce=\"' + nonce +",
									"            '\", ext=\"' + extension +",
									"            '\", mac=\"' + mac + '\"';",
									"    };",
									"    ",
									"    return {",
									"        generateAuthHeader: generateAuthHeader",
									"    };",
									"}();",
									"",
									"pm.environment.set('_AUTH_HEADER', BigMac.generateAuthHeader(",
									"    environment.macKeyId, environment.macKey, request));"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Authorization",
								"value": "{{_AUTH_HEADER}}"
							},
							{
								"key": "content-type",
								"value": "application/json",
								"disabled": true
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "{{url}}/security/principals/{{principalId}}",
							"host": [
								"{{url}}"
							],
							"path": [
								"security",
								"principals",
								"{{principalId}}"
							]
						},
						"description": ""
					},
					"response": []
				}
			]
		}
	]
}
